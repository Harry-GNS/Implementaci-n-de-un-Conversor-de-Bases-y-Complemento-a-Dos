% Informe: Implementación de un Conversor de Bases y Complemento a Dos
% Archivo listo para Overleaf

\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{courier} 
\usepackage{fancyhdr}
\geometry{margin=2.5cm}

% Encabezado y pie de página
\pagestyle{fancy}
\fancyhf{}
\lhead{Escuela Politécnica Nacional}
\cfoot{\thepage}
% Configuración de listings para Python
\lstset{
  language=Python,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  numberstyle=\tiny,     
  stepnumber=1,           
  numbersep=5pt,          
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  frame=single,
  tabsize=2,
  breaklines=true,
  breakatwhitespace=false,
  captionpos=b
}

\begin{document}

% ---------------- PORTADA ----------------
\begin{titlepage}
  \centering
  \vspace*{2cm}
  {\scshape\LARGE Escuela Politécnica Nacional \par}
  \vspace{1.5cm}
  {\huge\bfseries Implementación de un Conversor de Bases y Complemento a Dos \par}
  \vspace{1.0cm}
  {\Large Arquitectura de Computadores GR1CC \par}
  \vspace{2.0cm}

  {\large\bf Integrantes: \par}
  \vspace{0.4cm}
  {\large Harry Nicolás Guaján Simbana \par}
  \vspace{0.2cm}
  {\large OTRO \par}
  \vspace{0.2cm}
  {\large Otro \par}
  \vspace{0.2cm}
  {\large as \par}
  \vspace{2.0cm}

  {\large Fecha de entrega : 16 de nobiembre de 2025\par}
  \vspace{0.6cm}
  {\small Informe del proyecto del primer bimestre  \par}
  \vfill
  % Pie de página de la portada
  {\small Profesor:  MARTINEZ GORDON RONIE STALIN }
\end{titlepage}

% ---------------- RESUMEN / ABSTRACT ----------------
\begin{abstract}
Este informe describe la implementación de un conversor de bases y operaciones relacionadas con el Complemento a Dos (Ca2). El proyecto se divide en cuatro fases: conversiones desde decimal hacia otras bases, conversiones desde otras bases a decimal, representación y verificación en complemento a dos, y una función avanzada de suma/resta en Ca2. Se presentan objetivos, la metodología, el diseño e implementación de los algoritmos principales, y espacio para incluir imágenes de los métodos clave. Se explican los algoritmos implementados y se discuten resultados y conclusiones.
\end{abstract}

\tableofcontents
\newpage

% ---------------- INTRODUCCIÓN ----------------
\section{Introducción}
En el presente trabajo se aborda la implementación de un conversor de bases y herramientas para trabajar con números en Complemento a Dos. El objetivo es reforzar conceptos de representación binaria, conversión entre sistemas numéricos y operaciones aritméticas en representación con signo usando Ca2.

% ---------------- OBJETIVOS ----------------
\section{Objetivos}
\subsection{Objetivo general}
Implementar y documentar un conversor de bases y mecanismos de representación y verificación en Complemento a Dos, demostrando su uso en las operaciones aritméticas básicas.

\subsection{Objetivos específicos}
\begin{itemize}
  \item Implementar la conversión de números decimales a binario, octal y hexadecimal.
  \item Implementar la conversión de cadenas en base 2/8/16 hacia decimal con validación.
  \item Implementar la generación del Complemento a Dos para un número dado y la reconversión a decimal (método invertir+1 para negativos).
  \item Implementar y verificar suma y resta usando Ca2 y detectar overflow.
  \item Documentar y dejar espacios para imágenes que ilustren los métodos.
\end{itemize}

% ---------------- METODOLOGÍA ----------------
\section{Metodología}
Se desarrolló el código en Python en un único módulo que contiene las funciones principales. El trabajo siguió un enfoque iterativo: diseñar el algoritmo, implementarlo, probar casos típicos y documentar los resultados. Las fases se dividieron para facilitar pruebas y validaciones parciales.

% ---------------- DESARROLLO / FASES ----------------
\section{Desarrollo}
A continuación se describen en detalle las cuatro fases del proyecto, con explicación del algoritmo y un espacio reservado para incluir imágenes o diagramas de cada método.

\subsection{Fase 1: Decimal $\rightarrow$ Binario / Octal / Hexadecimal}
Objetivo: convertir un entero decimal no negativo a sus representaciones en base 2, 8 y 16.

\begin{figure}[H]
  \centering
  % Sustituya 'img_decimal_a_base.png' por su imagen en Overleaf
  \includegraphics[width=0.8\textwidth]{images/decimal_a_base_placeholder.png}
  \caption{Ilustración del proceso de divisiones sucesivas (reemplazar imagen).}
\end{figure}

Explicación del algoritmo: se aplican divisiones sucesivas por la base deseada; en cada paso se obtiene el residuo (un dígito de la nueva base) y se continúa con el cociente hasta llegar a cero. Los residuos recogidos forman la representación en la nueva base cuando se leen en orden inverso (último residuo = dígito más significativo). Este proceso admite bases hasta 16 usando una tabla de símbolos para dígitos mayores a 9.

\subsection{Fase 2: Binario/Octal/Hexadecimal $\rightarrow$ Decimal}
Objetivo: convertir una cadena que representa un número en base 2, 8 o 16 al valor entero decimal correspondiente.

\begin{figure}[H]
  \centering
  % Sustituya 'img_base_a_decimal.png' por su imagen en Overleaf
  \includegraphics[width=0.8\textwidth]{images/base_a_decimal_placeholder.png}
  \caption{Proceso de evaluación posicional para conversión a decimal (reemplazar imagen).}
\end{figure}

Explicación del algoritmo: se evalúa la cadena de dígitos de izquierda a derecha acumulando un valor: en cada paso se multiplica el acumulador por la base y se suma el valor del dígito actual (convertido desde su carácter). De este modo se realiza una suma ponderada por potencias de la base sin necesidad de potencias explícitas por cada posición.

\subsection{Fase 3: Complemento a Dos (representación y reconversión)}
Objetivo: generar la representación en Complemento a Dos (Ca2) para un entero con signo con N bits, y reconvertir desde Ca2 a decimal usando invertir+1 para negativos.

\begin{figure}[H]
  \centering
  % Sustituya 'img_complemento_a_dos.png' por su imagen en Overleaf
  \includegraphics[width=0.8\textwidth]{images/ca2_generacion_placeholder.png}
  \caption{Diagrama del proceso de generar Ca2 (reemplazar imagen).}
\end{figure}

Explicación del algoritmo de generación: primero se verifica que el número quepa en el rango representable con N bits; para positivos se calcula su binario y se rellena a N bits; para negativos se toma el valor absoluto, se convierte y rellena a N bits, se invierten los bits (complemento a uno) y se suma 1 para obtener la representación Ca2.

\begin{figure}[H]
  \centering
  % Sustituya 'img_ca2_reconversion.png' por su imagen en Overleaf
  \includegraphics[width=0.8\textwidth]{images/ca2_reconversion_placeholder.png}
  \caption{Reconversión de Ca2 a decimal usando invertir+1 (reemplazar imagen).}
\end{figure}

Explicación del algoritmo de reconversión: si el bit más significativo es 0, el número es positivo y se convierte directamente; si es 1, se invierten los bits y se suma 1 para obtener la magnitud, cuyo valor se toma como negativo. Este método (invertir+1) recupera la magnitud original en Ca2.

\subsection{Fase 4: Operaciones avanzadas — Suma y Resta usando Ca2}
Objetivo: realizar suma y resta de enteros utilizando la representación en Complemento a Dos con truncamiento a N bits y detección de overflow.

\begin{figure}[H]
  \centering
  % Sustituya 'img_suma_resta_ca2.png' por su imagen en Overleaf
  \includegraphics[width=0.8\textwidth]{images/suma_resta_ca2_placeholder.png}
  \caption{Esquema de suma/resta con truncamiento a N bits (reemplazar imagen).}
\end{figure}

Explicación del algoritmo: se representan ambos operandos en Ca2 con N bits, se realiza la operación aritmética en enteros, y el resultado se trunca a N bits aplicando una máscara. El valor truncado se interpreta con el método invertir+1 si el bit de signo es 1. Para detectar overflow se compara el resultado aritmético real con el rango representable $[-2^{N-1},2^{N-1}-1]$; si queda fuera, se reporta advertencia de overflow.

\paragraph{Nota sobre el desarrollo de menús y la interfaz:}
Durante el desarrollo las interfaces de menú se fueron construyendo en paralelo con las fases para facilitar pruebas interactivas. Se añadió una función de salida animada (`type_print`) para mejorar la legibilidad en consola y se decidió mantener la interfaz por consola (no interfaz gráfica) porque el objetivo principal era asegurar la corrección y trazabilidad del resultado, no la representación gráfica. Estas decisiones permitieron iterar rápidamente y centrarse en algoritmos y validación.

% ---------------- RESULTADOS ----------------
\section{Resultados}
Describa aquí los resultados de las pruebas que realice: ejemplos de conversiones, pruebas de valores límite (por ejemplo, para 8 bits: -128..127), pruebas de suma/resta con y sin overflow, y captura de pantallas (suba las imágenes a Overleaf y sustituya los placeholders).

% ---------------- CONCLUSIONES ----------------
\section{Conclusiones}
Incluya las conclusiones sobre la correcta implementación de los algoritmos, limitaciones encontradas (por ejemplo, manejo de entradas no enteras, whitespace o prefijos como "0x"), y posibles mejoras (por ejemplo: soporte para números fraccionarios, mejor validación de entradas, interfaz gráfica, o pruebas unitarias automatizadas).

% ---------------- RECOMENDACIONES / TRABAJO FUTURO ----------------
\section{Recomendaciones}
\begin{itemize}
  \item Añadir un conjunto de pruebas unitarias automáticas (pytest) para verificar conversión y Ca2 en diferentes tamaños de palabra.
  \item Incluir una pequeña interfaz gráfica o web para facilitar la interacción con el conversor.
  \item Documentar ejemplos concretos y casos límite dentro del informe (appendix con resultados de ejecución).
\end{itemize}

% ---------------- REFERENCIAS ----------------
\begin{thebibliography}{9}
\bibitem{t1} Patterson, D. A., Hennessy, J. L. (2013). Computer Organization and Design. (Referencias sobre representación y aritmética de enteros).
\bibitem{t2} Tanenbaum, A. (2016). Structured Computer Organization.
\end{thebibliography}

% ---------------- APÉNDICE (MATERIAL ADICIONAL) ----------------
\appendix
\section{Material adicional}
Si ya ha incluido las imágenes que ilustran los métodos en las secciones de desarrollo, no es necesario repetir el código aquí. El código fuente completo se encuentra en el repositorio del proyecto (archivo \texttt{src/conversor.py}) y las funciones principales se explican en detalle en las secciones de desarrollo del presente informe.

\vspace{1cm}

% ---------------- FIN ----------------
\end{document}
