% Informe: Implementación de un Conversor de Bases y Complemento a Dos
% Archivo listo para Overleaf
\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{courier}
\usepackage{fancyhdr}
\geometry{margin=2.5cm}
% Encabezado y pie de página
\pagestyle{fancy}
\fancyhf{}
\lhead{Escuela Politécnica Nacional}
\cfoot{\thepage}
% Configuración de listings para Python
\lstset{
  language=Python,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  frame=single,
  tabsize=2,
  breaklines=true,
  breakatwhitespace=false,
  captionpos=b
}
\begin{document}
% ---------------- PORTADA ----------------
\begin{titlepage}
  \centering
  \vspace*{2cm}
  {\scshape\LARGE Escuela Politécnica Nacional \par}
  \vspace{1.5cm}
  {\huge\bfseries Implementación de un Conversor de Bases y Complemento a Dos \par}
  \vspace{1.0cm}
  {\Large Arquitectura de Computadores GR1CC \par}
  \vspace{2.0cm}
  {\large\bf Integrantes: \par}
  \vspace{0.4cm}
  {\large Castañeda Morales Juan David \par}
  \vspace{0.2cm}
  {\large Guaján Simbana Harry Nicolás \par}
  \vspace{0.2cm}
  {\large Holguin Sánchez Anthony David \par}
  \vspace{0.2cm}
  {\large Moreta Chango Luis Esteban \par}

  \vspace{2.0cm}
  {\large Fecha de entrega : 17 de noviembre de 2025\par}
  \vspace{0.6cm}
  {\small Informe del proyecto del primer bimestre \par}
  \vfill
  % Pie de página de la portada
  {\small Profesor: MARTINEZ GORDON RONIE STALIN }
\end{titlepage}
% ---------------- RESUMEN / ABSTRACT ----------------
\begin{abstract}
El presente informe detalla la implementación de un conversor de bases numéricas y de herramientas para el manejo de la representación en complemento a dos. El proyecto se estructuró en cuatro fases principales: conversión de números decimales a binario, octal y hexadecimal; conversión inversa desde estas bases a decimal; generación y verificación de representaciones en complemento a dos; y operaciones de suma y resta en dicha representación con detección de desborde. Se describen los objetivos, la metodología empleada, el diseño e implementación de las funciones clave, y se reservan espacios para la inclusión de capturas ilustrativas. Finalmente, se analizan los resultados obtenidos y se presentan conclusiones.
\end{abstract}
\tableofcontents
\newpage
% ---------------- INTRODUCCIÓN ----------------
\section{Introducción}
En este informe se presenta el desarrollo de un conversor de sistemas numéricos y de funciones asociadas al complemento a dos. El trabajo busca consolidar los conocimientos adquiridos sobre representación de números en computadoras, conversiones entre bases y operaciones aritméticas con números con signo mediante la técnica de complemento a dos.
% ---------------- OBJETIVOS ----------------
\section{Objetivos}
\subsection{Objetivo general}
Desarrollar e implementar un conjunto de funciones en Python que permitan realizar conversiones entre bases numéricas y operaciones aritméticas en complemento a dos, incluyendo la detección de desborde.
\subsection{Objetivos específicos}
\begin{itemize}
  \item Implementar la conversión de números enteros decimales no negativos a sus equivalentes en binario, octal y hexadecimal.
  \item Desarrollar funciones para convertir cadenas en bases 2, 8 o 16 a su valor decimal, con validación de dígitos.
  \item Generar la representación en complemento a dos de enteros con signo para un ancho de bits fijo, y realizar la conversión inversa.
  \item Implementar operaciones de suma y resta en complemento a dos, con truncamiento a un número fijo de bits y detección de overflow.
  \item Documentar el proceso y reservar espacios para la inclusión de imágenes que ilustren los algoritmos implementados.
\end{itemize}
% ---------------- METODOLOGÍA ----------------
\section{Metodología}
El desarrollo se realizó en lenguaje Python, concentrando todas las funciones en un único módulo. Se adoptó un enfoque iterativo: diseño del algoritmo, codificación, pruebas con casos representativos y corrección de errores. Las fases se abordaron de manera secuencial para facilitar la validación parcial de cada componente.
% ---------------- DESARROLLO / FASES ----------------
\section{Desarrollo}
A continuación se detalla cada una de las cuatro fases del proyecto, incluyendo la explicación del algoritmo correspondiente y espacios para capturas de código.
\subsection{Fase 1: Decimal a Binario, Octal y Hexadecimal}
El propósito fue convertir un número entero decimal no negativo a su representación en la base solicitada (2, 8 o 16).
  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que implementa Decimal -> Base
  \includegraphics[width=0.8\textwidth]{arq1.png}
  \caption{Función decimal\_a\_base.}
\end{figure}
La conversión desde decimal se basa en repetir divisiones por la base indicada. En cada paso se toma el residuo como el siguiente dígito de la nueva base y se reemplaza el número por el cociente para continuar. Al finalizar, cuando el cociente es cero, los residuos se leen en orden inverso para formar el resultado. Para bases hasta dieciséis se usa una tabla de símbolos que asigna A a F a los valores del diez al quince. El valor cero se trata de forma directa devolviendo 0, y cuando se requiere un ancho fijo se completa con ceros a la izquierda.

\subsection{Fase 2: Binario, Octal y Hexadecimal a Decimal}
Esta fase consiste en interpretar una cadena en una base dada y calcular su valor decimal equivalente.
  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que implementa Base -> Decimal
  \includegraphics[width=0.8\textwidth]{arq2.png}
  \caption{Función base\_a\_decimal.}
\end{figure}
La conversión hacia decimal emplea evaluación posicional. Primero se normaliza la cadena y se verifica que cada carácter sea válido para la base indicada. Luego se recorre de izquierda a derecha acumulando un valor: en cada paso el acumulador se multiplica por la base y se suma el dígito actual convertido a entero. Este procedimiento implementa la suma ponderada por potencias de la base sin calcular potencias explícitas y permite detectar de inmediato cualquier dígito fuera de rango.
\subsection{Fase 3: Complemento a Dos (representación y reconversión)}
Se implementaron funciones para obtener la representación en complemento a dos de un entero con signo y para interpretarla de vuelta a decimal.
  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que genera Complemento a Dos
  \includegraphics[width=0.8\textwidth]{arq3.png}
  \caption{Función a\_complemento\_a\_dos.}
\end{figure}
La representación en complemento a dos con N bits inicia verificando que el valor esté dentro del intervalo representable. Si el número es no negativo, se obtiene su binario y se rellena hasta N bits. Si es negativo, se toma la magnitud en binario, se invierten todos los bits (complemento a uno) y se suma uno, aplicando una máscara de N bits para mantener el ancho. El bit más significativo actúa como bit de signo y la magnitud queda codificada en los bits restantes.
  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que reconvierte Ca2 a entero
  \includegraphics[width=0.8\textwidth]{arq4.png}
  \caption{Función ca2\_a\_decimal.}
\end{figure}
La interpretación de una cadena en complemento a dos depende del bit de signo. Si este bit es cero, la lectura es directa como un entero positivo. Si es uno, se recupera la magnitud invirtiendo los bits y sumando uno, y se asigna signo negativo al resultado. El proceso se realiza en N bits para evitar extensiones de signo no deseadas y reproducir exactamente la operación inversa a la generación.
\subsection{Fase 4: Operaciones avanzadas — Suma y Resta usando Ca2}
Se desarrollaron operaciones aritméticas directamente en representación complemento a dos.
  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que implementa suma y resta en Ca2
  \includegraphics[width=0.8\textwidth]{arq5.png}
  \caption{Captura de la función suma\_ca2.}
\end{figure}
La suma en complemento a dos calcula primero el resultado aritmético en enteros y luego aplica una máscara de N bits para simular el tamaño de palabra. Los operandos y el resultado se expresan en complemento a dos con relleno a N bits. El valor truncado se interpreta con signo revisando el bit más significativo y, si es necesario, aplicando la inversión y suma de uno. Existe desbordamiento cuando el resultado aritmético real queda fuera del intervalo representable con N bits; en ese caso, se indica la condición aunque la codificación truncada conserve solo los N bits menos significativos.

  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que implementa resta en Ca2
  \includegraphics[width=0.8\textwidth]{arq6.png}
  \caption{Captura de la función resta\_ca2.}
\end{figure}
La resta en complemento a dos sigue el mismo esquema: se calcula la diferencia en enteros, se trunca con máscara de N bits y se interpreta el resultado en complemento a dos. De forma equivalente puede verse como una suma entre A y el complemento a dos de B. La condición de desbordamiento se determina comparando el resultado aritmético real con el intervalo representable para el ancho elegido, y se señala cuando dicho valor no cabe en N bits con signo.
\paragraph{Nota sobre la interfaz:}
Se implementó un menú interactivo en consola para facilitar las pruebas durante el desarrollo. Además, se incluyó una función de impresión animada para mejorar la experiencia de usuario. Se optó por mantener una interfaz de línea de comandos, priorizando la depuración y la trazabilidad de los cálculos.
% ---------------- RESULTADOS ----------------
\section{Resultados}
Aqui podemos observar algunas ejecuciones del codigo
  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que implementa Decimal -> Base
  \includegraphics[width=0.8\textwidth]{fase1.png}
  \caption{Ejecucion Opcion 1}
\end{figure}
  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que implementa Decimal -> Base
  \includegraphics[width=0.8\textwidth]{fase2.png}
  \caption{Ejecucion Opcion 2}
\end{figure}
  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que implementa Decimal -> Base
  \includegraphics[width=0.8\textwidth]{fase3.png}
  \caption{Ejecucion Opcion 3}
\end{figure}
  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que implementa Decimal -> Base
  \includegraphics[width=0.8\textwidth]{fase4.png}
  \caption{Ejecucion Opcion 4.}
\end{figure}

% ---------------- CONCLUSIONES ----------------
\section{Conclusiones}
Las funciones desarrolladas cumplen satisfactoriamente con los objetivos establecidos, permitiendo conversiones precisas entre bases y operaciones correctas en complemento a dos, incluyendo la detección de desborde.
Los algoritmos resultaron eficientes y fieles a los métodos clásicos: divisiones sucesivas, evaluación posicional y manipulación bit a bit.
Las pruebas exhaustivas con valores típicos y extremos confirmaron la robustez de la implementación.
Entre las limitaciones identificadas destacan la validación parcial de entradas, el manejo básico de errores y la ausencia de soporte para números fraccionarios o pruebas unitarias automáticas.
% ---------------- RECOMENDACIONES / TRABAJO FUTURO ----------------
\section{Recomendaciones}
\begin{itemize}
  \item Implementar un conjunto de pruebas unitarias automatizadas utilizando pytest para cubrir un mayor número de casos.
  \item Desarrollar una interfaz gráfica o web que facilite la interacción con el usuario final.

\end{itemize}
% ---------------- REFERENCIAS ----------------

% ---------------- APÉNDICE (MATERIAL ADICIONAL) ----------------
% ---------------- FIN ----------------
\end{document}