% Informe: Implementación de un Conversor de Bases y Complemento a Dos
% Archivo listo para Overleaf

\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{courier} 
\usepackage{fancyhdr}
\geometry{margin=2.5cm}

% Encabezado y pie de página
\pagestyle{fancy}
\fancyhf{}
\lhead{Escuela Politécnica Nacional}
\cfoot{\thepage}
% Configuración de listings para Python
\lstset{
  language=Python,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  numberstyle=\tiny,     
  stepnumber=1,           
  numbersep=5pt,          
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  frame=single,
  tabsize=2,
  breaklines=true,
  breakatwhitespace=false,
  captionpos=b
}

\begin{document}

% ---------------- PORTADA ----------------
\begin{titlepage}
  \centering
  \vspace*{2cm}
  {\scshape\LARGE Escuela Politécnica Nacional \par}
  \vspace{1.5cm}
  {\huge\bfseries Implementación de un Conversor de Bases y Complemento a Dos \par}
  \vspace{1.0cm}
  {\Large Arquitectura de Computadores GR1CC \par}
  \vspace{2.0cm}

  {\large\bf Integrantes: \par}
  \vspace{0.4cm}
  {\large Harry Nicolás Guaján Simbana \par}
  \vspace{0.2cm}
  {\large OTRO \par}
  \vspace{0.2cm}
  {\large Otro \par}
  \vspace{0.2cm}
  {\large as \par}
  \vspace{2.0cm}

  {\large Fecha de entrega : 16 de nobiembre de 2025\par}
  \vspace{0.6cm}
  {\small Informe del proyecto del primer bimestre  \par}
  \vfill
  % Pie de página de la portada
  {\small Profesor:  MARTINEZ GORDON RONIE STALIN }
\end{titlepage}

% ---------------- RESUMEN / ABSTRACT ----------------
\begin{abstract}
Este informe describe la implementación de un conversor de bases y operaciones relacionadas con el Complemento a Dos (Ca2). El proyecto se divide en cuatro fases: conversiones desde decimal hacia otras bases, conversiones desde otras bases a decimal, representación y verificación en complemento a dos, y una función avanzada de suma/resta en Ca2. Se presentan objetivos, la metodología, el diseño e implementación de los algoritmos principales, y espacio para incluir imágenes de los métodos clave. Se explican los algoritmos implementados y se discuten resultados y conclusiones.
\end{abstract}

\tableofcontents
\newpage

% ---------------- INTRODUCCIÓN ----------------
\section{Introducción}
En el presente trabajo se aborda la implementación de un conversor de bases y herramientas para trabajar con números en Complemento a Dos. El objetivo es reforzar conceptos de representación binaria, conversión entre sistemas numéricos y operaciones aritméticas en representación con signo usando Ca2.

% ---------------- OBJETIVOS ----------------
\section{Objetivos}
\subsection{Objetivo general}
Implementar y documentar un conversor de bases y mecanismos de representación y verificación en Complemento a Dos, demostrando su uso en las operaciones aritméticas básicas.

\subsection{Objetivos específicos}
\begin{itemize}
  \item Implementar la conversión de números decimales a binario, octal y hexadecimal.
  \item Implementar la conversión de cadenas en base 2/8/16 hacia decimal con validación.
  \item Implementar la generación del Complemento a Dos para un número dado y la reconversión a decimal (método invertir+1 para negativos).
  \item Implementar y verificar suma y resta usando Ca2 y detectar overflow.
  \item Documentar y dejar espacios para imágenes que ilustren los métodos.
\end{itemize}

% ---------------- METODOLOGÍA ----------------
\section{Metodología}
Se desarrolló el código en Python en un único módulo que contiene las funciones principales. El trabajo siguió un enfoque iterativo: diseñar el algoritmo, implementarlo, probar casos típicos y documentar los resultados. Las fases se dividieron para facilitar pruebas y validaciones parciales.

% ---------------- DESARROLLO / FASES ----------------
\section{Desarrollo}
A continuación se describen en detalle las cuatro fases del proyecto, con explicación del algoritmo y un espacio reservado para incluir imágenes o diagramas de cada método.

\subsection{Fase 1: Decimal a Binario, Octal y Hexadecimal}
Objetivo: convertir un entero decimal no negativo a sus representaciones en base 2, 8 y 16.

  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que implementa Decimal -> Base
  \includegraphics[width=0.8\textwidth]{images/fase1_metodo_decimal_a_base.png}
  \caption{Captura de la función decimal\_a\_base.}
\end{figure}

\noindent\textbf{Resumen del algoritmo (Decimal $\rightarrow$ Base).} La función recibe un entero no negativo y la base destino (2, 8 o 16). Itera dividiendo el número por la base, guarda el residuo en cada paso y continúa con el cociente hasta que éste sea cero. Los residuos se leen en orden inverso para formar la representación final; para dígitos mayores a 9 se usa una tabla de símbolos (A--F). Se gestiona el caso 0 de forma explícita y se rellena (pad) según el tamaño solicitado cuando aplica.

\subsection{Fase 2: Binario, Octal y Hexadecimal a Decimal}
Objetivo: convertir una cadena que representa un número en base 2, 8 o 16 al valor entero decimal correspondiente.

  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que implementa Base -> Decimal
  \includegraphics[width=0.8\textwidth]{images/fase2_metodo_base_a_decimal.png}
  \caption{Captura de la función base\_a\_decimal.}
\end{figure}

La función valida cada carácter de la cadena según la base y lo convierte a su valor numérico. Recorre la cadena de izquierda a derecha acumulando: \texttt{acc = acc * base + digito}. Este método implementa la evaluación posicional de forma eficiente y detecta dígitos no válidos según la base.

\subsection{Fase 3: Complemento a Dos (representación y reconversión)}
Objetivo: generar la representación en Complemento a Dos (Ca2) para un entero con signo con N bits, y reconvertir desde Ca2 a decimal usando invertir+1 para negativos.

  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que genera Complemento a Dos
  \includegraphics[width=0.8\textwidth]{images/fase3_metodo_generar_ca2.png}
  \caption{Captura de la función a\_complemento\_a\_dos.}
\end{figure}

La función comprueba primero que el entero cabe en el rango de N bits. Para números positivos devuelve la representación binaria rellenada a N bits. Para negativos calcula la magnitud en binario a N bits, invierte los bits y suma 1 enmascarando a N bits para obtener la representación en complemento a dos.

  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que reconvierte Ca2 a entero
  \includegraphics[width=0.8\textwidth]{images/fase3_metodo_reconvertir_ca2.png}
  \caption{Captura de la función ca2\_a\_decimal.}
\end{figure}

Si el bit de signo es 0 la función interpreta la cadena como un entero positivo directo. Si el bit de signo es 1 invierte los bits, suma 1 y devuelve el resultado con signo negativo. La operación se realiza en un dominio de N bits y se enmascara para evitar desbordes intermedios.

\subsection{Fase 4: Operaciones avanzadas — Suma y Resta usando Ca2}
Objetivo: realizar suma y resta de enteros utilizando la representación en Complemento a Dos con truncamiento a N bits y detección de overflow.

  \begin{figure}[H]
  \centering
  % Captura del método en el código fuente que implementa suma y resta en Ca2
  \includegraphics[width=0.8\textwidth]{images/fase4_metodo_suma_resta_ca2.png}
  \caption{Captura de la función suma\_ca2.}
\end{figure}

Ambos operandos se codifican en N bits como complemento a dos. Se realiza la operación en el dominio entero y se aplica una máscara para truncar a N bits. El resultado truncado se interpreta como complemento a dos. Para detectar overflow se compara el resultado aritmético sin truncar con el rango representable $[-2^{N-1}, 2^{N-1}-1]$ y se marca la condición cuando corresponde.

\paragraph{Nota sobre el desarrollo de menús y la interfaz:}
Durante el desarrollo las interfaces de menú se fueron construyendo en paralelo con las fases para facilitar pruebas interactivas. Se añadió una función de salida animada (`type_print`) para mejorar la legibilidad en consola y se decidió mantener la interfaz por consola (no interfaz gráfica) porque el objetivo principal era asegurar la corrección y trazabilidad del resultado, no la representación gráfica. Estas decisiones permitieron iterar rápidamente y centrarse en algoritmos y validación.

% ---------------- RESULTADOS ----------------
\section{Resultados}
Describa aquí los resultados de las pruebas que realice: ejemplos de conversiones, pruebas de valores límite (por ejemplo, para 8 bits: -128..127), pruebas de suma/resta con y sin overflow, y captura de pantallas (suba las imágenes a Overleaf y sustituya los placeholders).

% ---------------- CONCLUSIONES ----------------
\section{Conclusiones}
Incluya las conclusiones sobre la correcta implementación de los algoritmos, limitaciones encontradas (por ejemplo, manejo de entradas no enteras, whitespace o prefijos como "0x"), y posibles mejoras (por ejemplo: soporte para números fraccionarios, mejor validación de entradas, interfaz gráfica, o pruebas unitarias automatizadas).

% ---------------- RECOMENDACIONES / TRABAJO FUTURO ----------------
\section{Recomendaciones}
\begin{itemize}
  \item Añadir un conjunto de pruebas unitarias automáticas (pytest) para verificar conversión y Ca2 en diferentes tamaños de palabra.
  \item Incluir una pequeña interfaz gráfica o web para facilitar la interacción con el conversor.
  \item Documentar ejemplos concretos y casos límite dentro del informe (appendix con resultados de ejecución).
\end{itemize}

% ---------------- REFERENCIAS ----------------
\begin{thebibliography}{9}
\bibitem{t1} Patterson, D. A., Hennessy, J. L. (2013). Computer Organization and Design. (Referencias sobre representación y aritmética de enteros).
\bibitem{t2} Tanenbaum, A. (2016). Structured Computer Organization.
\end{thebibliography}

% ---------------- APÉNDICE (MATERIAL ADICIONAL) ----------------
\appendix
\section{Material adicional}
Si ya ha incluido las imágenes que ilustran los métodos en las secciones de desarrollo, no es necesario repetir el código aquí. El código fuente completo se encuentra en el repositorio del proyecto (archivo \texttt{src/conversor.py}) y las funciones principales se explican en detalle en las secciones de desarrollo del presente informe.

\vspace{1cm}

% ---------------- FIN ----------------
\end{document}
